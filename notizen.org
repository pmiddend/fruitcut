* Brainstorming
- Links oben Schriftzug "Score: xxx"
- Die ersten paar Sekunden erscheint unten in der Mitte ein Schriftzug...

	Press and hold mouse, then drag to swing, release to start cutting
	
	...der langsam verschwindet
- Wenn der Score geupdatet wird, wird "langsam" hochgezählt, nicht abrupt
- Dann kommen die Früchte angeflogen, begleitet von einem "Wurfsound"
- Wenn man die Maustaste drückt und zieht, wird alle paar
  Millisekunden ein "Glowsprite" gespawnt, damit ein Schweif
  entsteht. Diese Sprites werden kleiner je nach Lebenszeit (oder
  transparenter?)
- Wenn der Benutzer die Maustaste loslässt, werden alle aktiven
  Früchte durchgegangen. Es wird geguckt, ob sie vor oder hinter der
  Cursor-Ebene sind. Wenn ja, wird nichts getan. Wenn sie weder
  komplett vor oder hinter der Ebene sind, wird zerteilt. Die Masse
  und der Schwerpunkt werden neu ausgerichtet und zwei neue Körper
  entstehen. Es wird ein Impuls in Richtung der Normale der Ebene
  gegeben, damit die Hälften voneinander "abprallen". 
- Es wird außerdem ein Sound aus einer Sammlung von Schnitt-Sounds abgespielt
- Außerdem wird die Schnittfläche mit Partikeln versehen, die einfach
  lose runterfallen. Die Partikel müssen die Farbe der Schnittfläche
  annehmen (muss wohl in der json gespeichert werden)
- Einige der Partikel können auch etwas "sprayen" von der
  Schnittfläche aus
- Auf der Holzwand im Hintergrund wird ein Decal platziert. Wenn das
  Spiel vorbei ist, soll die Holzwand vollgepflastert sein
- Es werden bei einem Schnitt Punkte vergeben, die proportional zur
  Größe der Schnittfläche sind.
- Mehrere zerschnittene Früchte schnell hintereinander geben einen
  Sonderbonsu. Die werden mit einer halbtransparenten, relativ großen
  Schrift in der exakten Mitte des Bildschirms dargestellt, sowie mit
  einem Sound hörbar gemacht.
- Es gibt einen Bonsu, wenn man bei 1337 Punkten ist
- Wenn man bei 31337 Punkten ist
- Wenn man bei 9000 Punkten ist
- Oben in der Mitte des Bildschirms ist der Rundentimer
- Wenn der Timer abläuft, wird ein Sound abgespielt, alle bisherigen
  Früchte fallen nach unten.
- Es werden Feuerwerkspartikel abgefeuert
- Es wird in der Mitte der Name des Spielers (in der json-Datei) und
  der Punktestand eingetragen.
- =events::prerender= (was immernoch nötig ist, um eine
  Zeichenreihenfolge reinzukriegen) und =events::render= rendern nicht
  in den Framebuffer, sondern erstmal in 'ne Textur, so kann man noch
  Postprocessing machen. =machine= kann das Postprocessing später
  machen. Nach dem Postprocessing wird die entstandene Textur in den
  Framebuffer gerendert. Danach wird =events::overlay= geschickt.
- Man muss sich die Decalsprites in einem separaten Spritesystem
  sammeln, wo auch das Hintergrundsprite drin ist. Dann muss es eine
  Funktion geben, die alle diese Sprites in eine Textur rendert. Diese
  Textur wird für den Hintergrund genommen. Die Funktion wird
  aufgerufen, wenn ein Decal neu hinzukommt (oder mehrere Decals). Das
  ganze kapselt man am besten.

* States nötig
- =ingame=
	- =running=
	- =gameover=

* Spielablauf
** Früchtedatenbank
... wird aus json eingelesen, besteht aus:

- Model
- Textur

** Timer
... wird gestartet. Wenn er abläuft, wird eine Frucht mit zufälliger
Ausrichtung und Geschwindigkeit (und Drehimpuls!) generiert.
** Endtimer
... ist ein Countdown und wird mit einem Wert aus der json-Datei
initialisiert. Wird in der Mitte des Bildschirms in großer Schrift
angezeigt (sekundengenau). Läuft er ab, wird in =gameover= gewechselt.
** Mausziehen
Der Benutzer drückt die Maustaste, hält gedrückt und lässt los. Die
beiden Punkte werden gespeichert, bilden eine Ebene und alle Früchte
werden mit dieser Ebene geschnitten.
** Zerschneiden
Es wird vorher geguckt, ob nicht evtl. alle Vertizes (bzw. die
Boundingbox) oberhalb bzw. unterhalb der Ebene sind. In dem Fall wird
nichts gemacht.

Ist dem nicht so, wird die Frucht zerschnitten. Es entstehen zwei neue
Früchte.
** Punkte
Man bekommt für jede zerschnittene Frucht pauschal Punkte
zugeschrieben (steht in der json-Datei). Die restlichen Punkte
berechnen sich aus dem Flächeninhalt der Schnittfläche.

* Zeichnen allgemein
Es gibt nun drei Zeichenevents:

1. Pre-Render: Hier wird das Hintergrundsprite gerendert und
   vielleicht noch andere Dinge, die im Hintergrund passieren sollen
2. Render: Hier werden die 3D-Objekte gezeichnet und der Tiefenpuffer ist hier an
3. Overlay-Render: Hier wird das Overlay (Konsole etc.) gezeichnet

* Code
** =fruit=
Die "instanziierten" Früchte sind in einer Struktur =fruit=
gespeichert und bestehen aus:

- Textur
- Vertexbuffer
- =mesh=
- bullet-Shape
- bullet-Körper

** =mesh=
Ein =mesh= besteht wiederum aus Punkten und Texturkoordinaten und es
sind Operationen darauf definiert, mit denen man neue =fruit=-Objekte
erstellen kann.

** fruit-Spawner
Ist eine Klasse mit einer Methode =spawn=, die aufgerufen wird, wenn
der Fruchttimer abläuft. Enthält:

- Referenz auf die Prototyp-Objekte
- Zufallsverteilungen für Position, Drehimpuls, Fruchtklasse

Die =spawn=-Methode gibt einen =unique_ptr= auf eine =fruit= zurück,
der dann in das =fruit=-Array eingetragen wird.

** =ingame=

Enthält:

- Hintergrundsprite
- Konsole
- Inputmanager
- Kamera

Tut:



** =running=
Es wird die /Früchtedatenbank/ aus dem json eingelesen (Subsektion von
=config.json=). Jede Frucht besteht aus einem =sge::model::object=,
einer =sge::renderer::texture_ptr=. Das beides wird in einer Klasse
=prototype= vereint und in einem =vector<prototype>= gespeichert.

Alle =fruit=-Objekte werden in einem =ptr_vector<fruit>=
gespeichert. Der ist anfangs leer.

Der /Fruchttimer/ wird ebenfalls in =running= gespeichert. Seine
Laufzeit ist durch eine /Zufallsvariable/ gegeben (die kann später noch
durch die Spielzeit moduliert werden). Läuft er ab, wird
=fruit_spawner::spawn= aufgerufen.

=running= enthält auch die /Physikwelt/. Im =events::tick=-Callback wird
die Physik gesteppt.

In =running= gibt es außerdem den =stop_timer=, der das Spiel
letztlich beendet. Der wird im Konstruktor auf die Sekunden gestellt,
die in der =config.json= stehen.

=running= enthält außerdem die /Konsole/, den /Inputmanager/ und die
/Kamera/.

In Reaktion auf =events::tick= steppt =running= die Physikwelt.

In Reaktion auf =events::pre_render= rendert =running= das
Hintergrundsprite.
